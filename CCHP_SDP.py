#!/usr/bin/env python
# @Time    : 4/11/2021 16:15
# @Author  : Lei Gao
# @Email    : leigao@umd.edu

from pyomo.environ import *
import pandas as pd
import numpy as np
import itertools
import time


# demands into dataframe
path = r'D:\Lei\work\CombinedSystemOperation\CCHPmodel_ceee_office\cchp_data.xlsx'
df_HD = pd.read_excel(path, sheet_name='heating_demand', header=0, index_col=0)
df_ED = pd.read_excel(path, sheet_name='electricity_demand', header=0, index_col=0)
df_EP = pd.read_excel(path, sheet_name='electricity_price', header=0, index_col=0)
df_Temp = pd.read_excel(path, sheet_name='temperature', header=0, index_col=0)
df_Sc = pd.read_excel(path, sheet_name='possibility', header=0, index_col=0)
df_StHt = pd.read_excel(path, sheet_name='storage_heating', header=0, index_col=0)
df_StEl = pd.read_excel(path, sheet_name='storage_electricity', header=0, index_col=0)


def subprob(t, i, j, s, ii, jj, cost):
    # MODEL CONSTRUCTION
    model = ConcreteModel()

    # SET DECLARATION
    # ## subsystems index
    model.SbSy = Set(initialize=['PM', 'ORC', 'Gr', 'ABH', 'EH', 'Bo'])
    model.SSEl = Set(initialize=['PM', 'ORC'])
    model.SSHt = Set(initialize=['ABH', 'EH', 'Bo'])
    model.SSFl = Set(initialize=['PM', 'Bo'])
    model.SSWH = Set(initialize=['ORC', 'ABH'])
    model.SSSt = Set(initialize=['El', 'Ht'])

    # PARAMETER DECLARATION
    # ## capacity
    model.CpEl = Param(model.SSEl, initialize={'PM': 6.0,
                                               'ORC': 2.5})
    model.CpHt = Param(model.SSHt, initialize={'ABH': 5,
                                               'EH': 5,
                                               'Bo': 5})
    model.CpSt = Param(model.SSSt, initialize={'El': 5,
                                               'Ht': 5})
    # ## demand, probability and temperature
    model.DeHt = Param(initialize=0, mutable=True)
    model.DeEl = Param(initialize=0, mutable=True)
    model.CtEl = Param(initialize=0, mutable=True)
    model.Temp = Param(initialize=0, mutable=True)
    model.Poss = Param(initialize=0, mutable=True)
    # fuel unit price ($/kJ)
    model.CtFl = Param(initialize=1.1763e-5)
    # ## assign values
    model.Poss = df_Sc[s][1]
    model.DeHt = df_HD[s][t]
    model.DeEl = df_ED[1][t]
    model.CtEl = df_EP[1][t]
    model.Temp = df_Temp[s][t]

    # VARIABLES DECLARATION
    # positive variables: partial load signal
    nnr = NonNegativeReals
    model.ApEl = Var(model.SSEl, within=Binary, initialize=1)
    model.ApHt = Var(model.SSHt, within=Binary, initialize=1)
    model.BtEl = Var(model.SSEl, bounds=(0.1, 1), initialize=0)  # 2
    model.BtHt = Var(model.SSHt, bounds=(0.1, 1), initialize=0)  # 3
    # energy input and output
    model.Elec = Var(model.SSEl, within=nnr, initialize=0)  # electricity generated subsystems #2
    model.Heat = Var(model.SSHt, within=nnr, initialize=0)  # heat generated by subsystems #3
    model.ElGd = Var(within=nnr, initialize=0)  # from grid for electricity demand #1*sc
    model.ElEH = Var(within=nnr, initialize=0)  # from grid for vapor compression heat pump #1*sc
    # heat recovery from waste heat
    model.HtWH = Var(model.SSWH, within=nnr, initialize=0)  # waste heat absorbed by subsys #2*sc
    # fuel related
    model.Fuel = Var(model.SSFl, within=nnr, initialize=0)  # fuel for boiler or PM #2*sc
    model.FlTt = Var(within=nnr, initialize=0)  # total fuel consumption #1*sc
    # subsystem efficiency
    #    model.EfSS = Var(model.SbSy, bounds=(0, 5), initialize=0)  # efficiency of each subsystems #5*sc
    #    model.EfWH = Var(bounds=(0, 1), initialize=0)  # efficiency of waste heat #1*sc
    # additional variable
    # model.zEl = Var(model.SSEl, within=nnr, initialize=0)
    # model.zHt = Var(model.SSHt, within=nnr, initialize=0)
    model.zEl = Var(model.SSEl, bounds=(0, 1), initialize=0)
    model.zHt = Var(model.SSHt, bounds=(0, 1), initialize=0)

    # VARIABLES DECLARATION
    # energy balance of prime mover
    def _pm(m):
        return m.zEl['PM'] * m.CpEl['PM'] == m.Fuel['PM'] * (-0.001357 * m.Temp + 0.161708)

    model.pm_st = Constraint(rule=_pm)

    # energy balance of absorption heat pump
    def _abh(m):
        return m.zHt['ABH'] * m.CpHt['ABH'] == m.HtWH['ABH'] * (
                1.45 + 0.007737 * m.Temp - 0.04782 * m.BtHt['ABH'] - 0.0002651 * m.Temp ** 2 + 0.006368 * m.Temp * m.BtHt['ABH'])

    model.abh_st = Constraint(rule=_abh)

    # energy balance of ORC
    def _orc(m):
        return m.zEl['ORC'] * m.CpEl['ORC'] == m.HtWH['ORC'] * (-0.001357 * m.Temp + 0.161708)

    model.orc_st = Constraint(rule=_orc)

    # energy balance of electric heat pump
    def _eh(m):
        return m.zHt['EH'] * m.CpHt['EH'] == m.ElEH * (
                    3.142 + 0.1087 * m.Temp + 0.1208 * m.BtHt['EH'] + 0.001161 * m.Temp ** 2
                    - 0.03463 * m.Temp * m.BtHt['EH'])

    model.eh_st = Constraint(rule=_eh)

    # energy balance of boiler
    def _bo(m):
        return m.zHt['Bo'] * m.CpHt['Bo'] == m.Fuel['Bo'] * (1.572 * m.BtHt['Bo'] / (0.1745 + 1.744 * m.BtHt['Bo']))

    model.bo_st = Constraint(rule=_bo)

    # waste heat generated by PM #1*sc
    def _rh(m):
        return m.Fuel['PM'] * (0.0474 - 0.000303 * m.Temp + 0.3866 * m.BtEl['PM'] - 2.8e-6 * m.Temp ** 2
                               + 0.0001041 * m.Temp * m.BtEl['PM'] - 0.2182 * m.BtEl['PM'] ** 2) >= sum(
            m.HtWH[SSWH] for SSWH in m.SSWH)  # loss constraint

    model.rh_st = Constraint(rule=_rh)

    # constraints of subsystems efficiency
    # boiler efficiency #1*sc
    """
    def _eta_bo(m):
        return 0.9 == m.EfSS['Bo']
    model.eta_bo_st = Constraint(rule=_eta_bo)

    # ORC efficiency #1*sc
    def _eta_orc(m):
        return 0.3 == m.EfSS['ORC']
    model.eta_orc_st = Constraint(rule=_eta_orc)

    # ABH efficiency #1*sc
    def _eta_abh(m):
        return 0.8 == m.EfSS['ABH']
    model.eta_abh_st = Constraint(rule=_eta_abh)

    # EH efficiency #1*sc
    def _eta_eh(m):
        return 4.0 == m.EfSS['EH']
    model.eta_eh_st = Constraint(rule=_eta_eh)

    # PM efficiency #1*sc
    def _eta_pm(m):
        return 0.3 == m.EfSS['PM']
    model.eta_pm_st = Constraint(rule=_eta_pm)

    # WH efficiency #1*sc
    def _eta_rh(m):
        return 0.5 == m.EfWH
    model.eta_rh_st = Constraint(rule=_eta_rh)
    """

    # constraints of energy demand
    # heating demand #1*sc*Stag
    def _dm_ht(m):
        return sum(m.zHt[SSHt] * m.CpHt[SSHt] for SSHt in m.SSHt) \
               + (df_StHt[1][i] - df_StHt[1][ii]) * m.CpSt['Ht'] >= m.DeHt

    model.dm_ht_st = Constraint(rule=_dm_ht)

    # electricity demand #1*sc*Stag
    def _dm_el(m):
        return sum(m.zEl[SSEl] * m.CpEl[SSEl] for SSEl in m.SSEl) \
               + m.ElGd + (df_StEl[1][j] - df_StEl[1][jj]) * m.CpSt['El'] >= m.DeEl

    model.dm_el_st = Constraint(rule=_dm_el)

    # constraints of additional variable z (heating)
    def _zht_1(m, ht):
        return m.zHt[ht] >= m.ApHt[ht] * 0.1

    model.zht_1_st = Constraint(model.SSHt, rule=_zht_1)

    def _zht_2(m, ht):
        return m.zHt[ht] <= m.ApHt[ht] * 1

    model.zht_2_st = Constraint(model.SSHt, rule=_zht_2)

    def _zht_3(m, ht):
        return m.zHt[ht] >= m.BtHt[ht] - (1 - m.ApHt[ht]) * 1

    model.zht_3_st = Constraint(model.SSHt, rule=_zht_3)

    def _zht_4(m, ht):
        return m.zHt[ht] <= m.BtHt[ht] - (1 - m.ApHt[ht]) * 0.1

    model.zht_4_st = Constraint(model.SSHt, rule=_zht_4)

    def _zht_5(m, ht):
        return m.zHt[ht] <= m.BtHt[ht] + (1 - m.ApHt[ht]) * 1

    model.zht_5_st = Constraint(model.SSHt, rule=_zht_5)

    # constraints of additional variable z (electricity)
    def _zel_1(m, el):
        return m.zEl[el] >= m.ApEl[el] * 0.1

    model.zel_1_st = Constraint(model.SSEl, rule=_zel_1)

    def _zel_2(m, el):
        return m.zEl[el] <= m.ApEl[el] * 1

    model.zel_2_st = Constraint(model.SSEl, rule=_zel_2)

    def _zel_3(m, el):
        return m.zEl[el] >= m.BtEl[el] - (1 - m.ApEl[el]) * 1

    model.zel_3_st = Constraint(model.SSEl, rule=_zel_3)

    def _zel_4(m, el):
        return m.zEl[el] <= m.BtEl[el] - (1 - m.ApEl[el]) * 0.1

    model.zel_4_st = Constraint(model.SSEl, rule=_zel_4)

    def _zel_5(m, el):
        return m.zEl[el] <= m.BtEl[el] + (1 - m.ApEl[el]) * 1

    model.zel_5_st = Constraint(model.SSEl, rule=_zel_5)

    # OBJECTIVE DECLARATION
    def _obj(m):
        # return m.CtFl*sum(m.Fuel[SSFl] for SSFl in m.SSFl)*3600 + m.CtEl * (m.ElGd + m.ElEH) + cost
        return m.CtFl * sum(m.Fuel[SSFl] for SSFl in m.SSFl) * 3600 + m.CtEl * (m.ElGd + m.ElEH) + cost

    model.obj = Objective(rule=_obj, sense=minimize)

    return model



"""
solver_manager = SolverManagerFactory('neos')
opt = SolverFactory('cbc')
# available NLP solvers from neos: knitro; conopt; l-bfgs-b; lancelot; loqo; mosek; snopt
"""
solver = "scip"
solver_io = "nl"
opt = SolverFactory(solver, solver_io=solver_io)
# opt.options['expect_infeasible_problem'] = 'no'
"""
opt.options['acceptable_tol'] = 0.001
opt.options['ms_enable'] = 1
opt.options['ms_maxsolves'] = 0
opt.options['par_numthreads'] = 12
opt.options['ms_savetol'] = 0.0001
opt.options['ms_num_to_save'] = 3
opt.options['ms_maxtime_cpu'] = 600
"""
stream_solver = False  # True prints solver output to screen
keepfiles = False  # True prints intermediate file names (.nl,.sol,...)

# stor_ht = range(1, df_StHt.size+1)
# stor_el = range(1, df_StEl.size+1)
# scen = range(1, df_Sc.size+1)
f = np.zeros([len(df_HD) + 1, df_StHt.size + 1, df_StEl.size + 1, df_Sc.size + 1])
cache_st_ht = np.zeros([len(df_HD) + 1, df_StHt.size + 1, df_StEl.size + 1, df_Sc.size + 1])
cache_st_el = np.zeros([len(df_HD) + 1, df_StHt.size + 1, df_StEl.size + 1, df_Sc.size + 1])
cache_al_pm = np.zeros([len(df_HD) + 1, df_StHt.size + 1, df_StEl.size + 1, df_Sc.size + 1])
cache_bt_pm = np.zeros([len(df_HD) + 1, df_StHt.size + 1, df_StEl.size + 1, df_Sc.size + 1])
cache_al_orc = np.zeros([len(df_HD) + 1, df_StHt.size + 1, df_StEl.size + 1, df_Sc.size + 1])
cache_bt_orc = np.zeros([len(df_HD) + 1, df_StHt.size + 1, df_StEl.size + 1, df_Sc.size + 1])
cache_al_abh = np.zeros([len(df_HD) + 1, df_StHt.size + 1, df_StEl.size + 1, df_Sc.size + 1])
cache_bt_abh = np.zeros([len(df_HD) + 1, df_StHt.size + 1, df_StEl.size + 1, df_Sc.size + 1])
cache_al_bo = np.zeros([len(df_HD) + 1, df_StHt.size + 1, df_StEl.size + 1, df_Sc.size + 1])
cache_bt_bo = np.zeros([len(df_HD) + 1, df_StHt.size + 1, df_StEl.size + 1, df_Sc.size + 1])
cache_al_eh = np.zeros([len(df_HD) + 1, df_StHt.size + 1, df_StEl.size + 1, df_Sc.size + 1])
cache_bt_eh = np.zeros([len(df_HD) + 1, df_StHt.size + 1, df_StEl.size + 1, df_Sc.size + 1])
cost = np.zeros([len(df_HD) + 2, df_StHt.size + 1, df_StEl.size + 1])

# for t in range(len(df_HD), 0, -1):
for t in range(24, 0, -1):
    print('Solve the ' + str(t) + ' stage problem')
    for i, j in itertools.product(range(1, df_StHt.size + 1), range(1, df_StEl.size + 1)):
        print('    Solve the state combination of heating storage: ' + str(
            df_StHt[1][i]) + ' and electricity storage: ' + str(df_StEl[1][j]))
        start = time.time()
        for s in range(1, df_Sc.size + 1):
            z = 999999
            # SAVE DATA
            for ii, jj in itertools.product(range(1, df_StHt.size + 1), range(1, df_StEl.size + 1)):
                m = subprob(t, i, j, s, ii, jj, cost[t + 1, ii, jj])
                results = opt.solve(m, keepfiles=keepfiles, tee=stream_solver)
                # results = solver_manager.solve(m,opt=opt, tee=True)
                obj = value(m.obj)
                # SAVE DATA
                if obj < z:
                    z = obj
                    f[t, i, j, s] = z
                    cache_st_ht[t, i, j, s] = df_StHt[1][ii]
                    cache_st_el[t, i, j, s] = df_StEl[1][jj]
                    cache_al_pm[t, i, j, s] = value(m.ApEl['PM'])
                    cache_bt_pm[t, i, j, s] = value(m.BtEl['PM'])
                    cache_al_orc[t, i, j, s] = value(m.ApEl['ORC'])
                    cache_bt_orc[t, i, j, s] = value(m.BtEl['ORC'])
                    cache_al_abh[t, i, j, s] = value(m.ApHt['ABH'])
                    cache_bt_abh[t, i, j, s] = value(m.BtHt['ABH'])
                    cache_al_bo[t, i, j, s] = value(m.ApHt['Bo'])
                    cache_bt_bo[t, i, j, s] = value(m.BtHt['Bo'])
                    cache_al_eh[t, i, j, s] = value(m.ApHt['EH'])
                    cache_bt_eh[t, i, j, s] = value(m.BtHt['EH'])

            print('        The best combination under scen ' + str(s) + ' is StHt: ' + str(
                cache_st_ht[t, i, j, s]) + ' and StEl: ' + str(cache_st_el[t, i, j, s]))

        cost[t, i, j] = sum(df_Sc[s][1] * f[t, i, j, s] for s in range(1, df_Sc.size + 1))
        print('    The total cost is: ' + str(cost[t, i, j]))
        end = time.time()
        usedtime = end - start
        print('    Used time is: ' + str(usedtime))

#!/usr/bin/env python
# @Time    : 4/6/2021 15:45
# @Author  : Lei Gao
# @Email    : leigao@umd.edu
# 2 stages
from pyomo.environ import *
from pyomo.opt import SolverFactory
import pandas as pd

path = r'D:\Lei\work\CombinedSystemOperation\CCHPmodel_ceee_office\cchp_data.xlsx'
df_HD = pd.read_excel(path, sheet_name='heating_demand', header=0, index_col=0)
df_ED = pd.read_excel(path, sheet_name='electricity_demand', header=0, index_col=0)
df_EP = pd.read_excel(path, sheet_name='electricity_price', header=0, index_col=0)
df_Temp = pd.read_excel(path, sheet_name='temperature', header=0, index_col=0)
df_Sc = pd.read_excel(path, sheet_name='possibility', header=0, index_col=0)

# set declaration
# subsystems index
model = ConcreteModel()
model.SbSy = Set(initialize=['PM', 'ORC', 'Gr', 'ABH', 'EH', 'Bo'])  # all subsystems
model.SSEl = Set(initialize=['PM', 'ORC'])  # electricity subsystems
model.SSHt = Set(initialize=['ABH', 'EH', 'Bo'])  # heating subsystems
model.SSFl = Set(initialize=['PM', 'Bo'])  # fuel consumption subsystems
model.SSWH = Set(initialize=['ORC', 'ABH'])  # waste heat consumption subsystems
# scenario and stage number
model.sc = Param(initialize=11)
model.st = Param(initialize=12)
model.Scen = RangeSet(1, model.sc)
model.Stag = RangeSet(7, model.st)  # stage number

# parameter declaration
# capacity
model.CpEl = Param(model.SSEl, initialize={'PM': 6.0, 'ORC': 2.5})  # capacity of electricity subsystem
model.CpHt = Param(model.SSHt, initialize={'ABH': 7, 'EH': 7, 'Bo': 7})  # capacity of heating subsystem
model.CtFl = Param(initialize=1.1763e-5)  # fuel unit price ($/kJ)
# demand, probability and temperature initialization
model.DeHt = Param(model.Stag, model.Scen, initialize=0, mutable=True)
model.DeEl = Param(model.Stag, initialize=0, mutable=True)
model.CtEl = Param(model.Stag, initialize=0, mutable=True)
model.Temp = Param(model.Stag, model.Scen, initialize=0, mutable=True)
model.Poss = Param(model.Scen, initialize=0, mutable=True)
for i in model.Stag:
    model.DeEl[i] = df_ED[1][i]
    model.CtEl[i] = df_EP[1][i]
    for j in model.Scen:
        model.DeHt[i, j] = df_HD[j][i]
        model.Temp[i, j] = df_Temp[j][i]
        model.Poss[j] = df_Sc[j][1]


# create a block for stage related constraints
def Stag_block(b, t):
    # variable declaration
    # binary variables: on-off signal
    b.ApEl = Var(model.SSEl, within=Binary, initialize=1)
    b.ApHt = Var(model.SSHt, within=Binary, initialize=1)
    # positive variables: partial load signal
    b.BtEl = Var(model.SSEl, model.Scen, within=NonNegativeReals, bounds=(0, 1), initialize=0)
    b.BtHt = Var(model.SSHt, model.Scen, within=NonNegativeReals, bounds=(0, 1), initialize=0)
    # energy input and output
    b.StSE = Var(model.Scen, within=NonNegativeReals, bounds=(0, 2), initialize=0)
    b.StSH = Var(model.Scen, within=NonNegativeReals, bounds=(0, 2), initialize=0)
    b.Elec = Var(model.SSEl, model.Scen, within=NonNegativeReals)  # electricity generated by electricity subsystems
    b.Heat = Var(model.SSHt, model.Scen, within=NonNegativeReals)  # heat generated by heating subsystems
    b.ElGd = Var(model.Scen, within=NonNegativeReals)  # electricity purchased from grid for electricity demand
    b.ElEH = Var(model.Scen, within=NonNegativeReals)  # electricity purchased from grid for vapor compression heat pump
    # heat recovery from waste heat
    b.HtWH = Var(model.SSWH, model.Scen, within=NonNegativeReals)  # waste heat absorbed by waste heat driven components
    # fuel related
    b.Fuel = Var(model.SSFl, model.Scen, within=NonNegativeReals)  # fuel consumption of boiler or PM
    b.FlTt = Var(model.Scen, within=NonNegativeReals)  # total fuel consumption
    # subsystem efficiency
    b.EfSS = Var(model.SbSy, model.Scen)  # efficiency of each subsystems
    b.EfWH = Var(model.Scen)  # efficiency of waste heat

    # constraints of energy balance
    def Elec_output_rule(b, SSEl, Scen):
        return b.ApEl[SSEl] * b.BtEl[SSEl, Scen] * model.CpEl[SSEl] == b.Elec[SSEl, Scen]
    def Heat_output_rule(b, SSHt, Scen):
        return b.ApHt[SSHt] * b.BtHt[SSHt, Scen] * model.CpHt[SSHt] == b.Heat[SSHt, Scen]
    def HtCons_ORC_rule(b, Scen):
        return b.HtWH['ORC', Scen] * b.EfSS['ORC', Scen] == b.Elec['ORC', Scen]
    def HtCons_ABH_rule(b, Scen):
        return b.HtWH['ABH', Scen] * b.EfSS['ABH', Scen] == b.Heat['ABH', Scen]
    def HtCons_EH_rule(b, Scen):
        return b.ElEH[Scen] * b.EfSS['EH', Scen] == b.Heat['EH', Scen]
    def FlCons_PM_rule(b, Scen):
        return b.Fuel['PM', Scen] * b.EfSS['PM', Scen] == b.Elec['PM', Scen]
    def FlCons_Bo_rule(b, Scen):
        return b.Fuel['Bo', Scen] * b.EfSS['Bo', Scen] == b.Heat['Bo', Scen]
    def WHGene_PM_rule(b, Scen):
        return b.Fuel['PM', Scen] * b.EfWH[Scen] >= sum(b.HtWH[SSWH, Scen] for SSWH in model.SSWH)  # loss constraint
    def Flcons_Tt_rule(b, Scen):
        return sum(b.Fuel[SSFl, Scen] for SSFl in model.SSFl) * 3600 == b.FlTt[Scen]
    b.Elec_output_st = Constraint(model.SSEl, model.Scen, rule=Elec_output_rule)
    b.Heat_output_st = Constraint(model.SSHt, model.Scen, rule=Heat_output_rule)
    b.HtCons_ORC_st = Constraint(model.Scen, rule=HtCons_ORC_rule)
    b.HtCons_ABH_st = Constraint(model.Scen, rule=HtCons_ABH_rule)
    b.HtCons_EH_st = Constraint(model.Scen, rule=HtCons_EH_rule)
    b.FlCons_PM_st = Constraint(model.Scen, rule=FlCons_PM_rule)
    b.FlCons_Bo_st = Constraint(model.Scen, rule=FlCons_Bo_rule)
    b.WHGene_PM_st = Constraint(model.Scen, rule=WHGene_PM_rule)
    b.Flcons_Tt_st = Constraint(model.Scen, rule=Flcons_Tt_rule)

    # constraints of subsystems efficiency
    def Effi_Bo_rule(b, Scen):
        # return 1.572*b.BtHt['Boiler', Scen]/(0.1745+1.744*b.BtHt['Boiler', Scen]) == b.EfSS['Boiler', Scen]
        return b.BtHt['Bo', Scen] == 0.85
    def Effi_ORC_rule(b, Scen):
        return -0.001357 * model.Temp[t, Scen] + 0.161708 == b.EfSS['ORC', Scen]
    def Effi_ABH_rule(b, Scen):
        return 1.45 + 0.007737 * model.Temp[t, Scen] - 0.04782 * b.BtHt['ABH', Scen] - \
               0.0002651 * model.Temp[t, Scen] ** 2 + 0.006368 * model.Temp[t, Scen] * b.BtHt['ABH', Scen] == \
               b.EfSS['ABH', Scen]
    def Effi_EH_rule(b, Scen):
        return 3.142 + 0.1087 * model.Temp[t, Scen] + 0.1208 * b.BtHt['EH', Scen] + \
               0.001161 * model.Temp[t, Scen] ** 2 - 0.03463 * model.Temp[t, Scen] * b.BtHt['EH', Scen] == \
               b.EfSS['EH', Scen]
    def Effi_PM_rule(b, Scen):
        return 0.0474 - 0.000303 * model.Temp[t, Scen] + 0.3866 * b.BtEl['PM', Scen] - \
               2.8e-6 * model.Temp[t, Scen] ** 2 + 0.0001041 * model.Temp[t, Scen] * b.BtEl['PM', Scen] - \
               0.2182 * b.BtEl['PM', Scen] ** 2 == b.EfSS['PM', Scen]
    def Effi_WH_rule(b, Scen):
        return 0.8952 - 0.0002987 * model.Temp[t, Scen] - 0.7999 * b.BtEl['PM', Scen] + \
               1.568e-5 * model.Temp[t, Scen] ** 2 + 0.0003575 * model.Temp[t, Scen] * b.BtEl['PM', Scen] + \
               0.4239 * b.BtEl['PM', Scen] ** 2 == b.EfWH[Scen]
    b.Effi_Bo_st = Constraint(model.Scen, rule=Effi_Bo_rule)
    b.Effi_ORC_st = Constraint(model.Scen, rule=Effi_ORC_rule)
    b.Effi_ABH_st = Constraint(model.Scen, rule=Effi_ABH_rule)
    b.Effi_EH_st = Constraint(model.Scen, rule=Effi_EH_rule)
    b.Effi_PM_st = Constraint(model.Scen, rule=Effi_PM_rule)
    b.Effi_WH_st = Constraint(model.Scen, rule=Effi_WH_rule)


# constraints of energy demand
# heating demand
def dema_Ht_link(m, Scen, t):
    if t == m.Stag.first():
        return sum(m.block[t].Heat[SSHt, Scen] for SSHt in model.SSHt) + \
               0 - m.block[t].StSH[Scen] >= model.DeHt[t, Scen]
    else:
        return sum(m.block[t].Heat[SSHt, Scen] for SSHt in model.SSHt) + \
               m.block[t - 1].StSH[Scen] - m.block[t].StSH[Scen] >= model.DeHt[t, Scen]


# electricity demand
def dema_El_link(m, Scen, t):
    if t == m.Stag.first():
        return sum(m.block[t].Elec[SSEl, Scen] for SSEl in model.SSEl) + \
               m.block[t].ElGd[Scen] + 0 - m.block[t].StSE[Scen] >= model.DeEl[t]
    else:
        return sum(m.block[t].Elec[SSEl, Scen] for SSEl in model.SSEl) + \
               m.block[t].ElGd[Scen] + m.block[t - 1].StSE[Scen] - m.block[t].StSE[Scen] >= model.DeEl[t]


model.block = Block(model.Stag, rule=Stag_block)
model.dema_Ht_st = Constraint(model.Scen, model.Stag, rule=dema_Ht_link)
model.dema_El_st = Constraint(model.Scen, model.Stag, rule=dema_El_link)


# objective
def objective_rule(model):
    return sum(model.Poss[Scen] * (model.CtFl * model.block[t].FlTt[Scen] + model.CtEl[t] * (
            model.block[t].ElGd[Scen] + model.block[t].ElEH[Scen])) for Scen in model.Scen for t in model.Stag)


model.obj = Objective(rule=objective_rule)

# %%

# opt = SolverFactory('couenne')
# solver_manager = SolverManagerFactory('neos')
# import time
#
# start = time.time()
# result = solver_manager.solve(model, opt=opt, tee=True)
# end = time.time()
# runtime = end - start
# print(runtime)
# model.display()

# solver_manager = SolverManagerFactory('neos')
# solver = 'sci'  # ipopt; bonmin; couenne; gurobi; asl:scip, executable=r"C:\Program Files\SCIPOptSuite 7.0.2\bin\scip"
# solver_io = 'neos'
stream_solver = True  # True prints solver output to screen
keepfiles = False  # True prints intermediate file names (.nl,.sol,...)
# opt = SolverFactory(solver, solver_io=solver_io)
# opt = SolverFactory(solver)
opt = SolverFactory("scip", solver_io="nl")
# solver_manager = SolverManagerFactory('neos')
## Send the model to ipopt and collect the solution
print("INITIAL SOLVE")
# results including any values for previously declared IMPORT /
# IMPORT_EXPORT Suffix components will be automatically loaded into the
# model
# results = opt.solve(model)
# results = opt.solve(model, tee=stream_solver)
results = opt.solve(model, keepfiles=keepfiles, tee=stream_solver)
###
model.display()

"""
### Declare all suffixes 
# Ipopt bound multipliers (obtained from solution)
model.ipopt_zL_out = Suffix(direction=Suffix.IMPORT)
model.ipopt_zU_out = Suffix(direction=Suffix.IMPORT)
# Ipopt bound multipliers (sent to solver)
model.ipopt_zL_in = Suffix(direction=Suffix.EXPORT)
model.ipopt_zU_in = Suffix(direction=Suffix.EXPORT)
# Obtain dual solutions from first solve and send to warm start
model.dual = Suffix(direction=Suffix.IMPORT_EXPORT)
###

### Set Ipopt options for warm-start
# The current values on the ipopt_zU_out and
# ipopt_zL_out suffixes will be used as initial 
# conditions for the bound multipliers to solve
# the new problem
model.ipopt_zL_in.update(model.ipopt_zL_out)
model.ipopt_zU_in.update(model.ipopt_zU_out)
opt.options['warm_start_init_point'] = 'yes'
opt.options['warm_start_bound_push'] = 1e-6
opt.options['warm_start_mult_bound_push'] = 1e-6
opt.options['mu_init'] = 1e-6
#opt.options['max_iter'] =6000
###

### Send the model and suffix information to ipopt and collect the solution
print("") 
print("WARM-STARTED SOLVE")
# The solver plugin will scan the model for all active suffixes
# valid for importing, which it will load into the model
results = opt.solve(model,keepfiles=keepfiles,tee=stream_solver)
model.display()
###
"""
